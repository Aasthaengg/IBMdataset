#Educational DP Contest
#I-Coins

n = int(input())
lst1 = list(map(float,input().split()))

#dp table
dp = [[0.0]*(n+1) for _ in range(n+1)] #確率を0で初期化(2次元)
dp[0][0] = 1.0 #0番目は存在しないので1で初期化(単位元のような感じ。乗算だから単位元は1)


#process1
#dp[i][j]は、i回までのコインを投げて、j枚が表の確率。
#つまり、ループの内側がn回表の確率、外側がコインの枚数となる
#但し、i回までのコインでi枚以上の表は出ないので、jのループはi迄とする。
"""
図にするとこんなかんじ
    0回表,1回表,2回表...
0枚目[[1.0, 0.0, 0.0, 0.0],
1枚目[0.7, 0.3, 0.0, 0.0], #0.7で1枚中0枚が表,0.3で1枚中1枚が表
2枚目[0.28, 0.54, 0.18, 0.0],
3枚目[0.056, 0.33, 0.468, 0.144]] #0.056+0.33で半分未満が表、0.468+0.144で半分以上が表
"""
for i in range(1,n+1):
    for j in range(i+1): #jはピラミッド状に増えていく
        dp[i][j] = dp[i-1][j]*(1-lst1[i-1]) #裏になる確率
        if j > 0: #j-1を参照できるなら
            dp[i][j] += dp[i-1][j-1]*lst1[i-1] #表になる確率

#output process
#問題はdp[i][j] >= 0.5となる確率なので、j>= 0.5 = 表の枚数/全体の枚数
#となるj以上の確率の合計が答え(ちなみに、任意のdp[i]の合計sum(dp[i]) == 1となる)
ans = 0.0
for i in range((n+1)//2,n+1): #j(表が出る枚数)が半分以上のところから全部のところまでの確率の合計
    ans += dp[-1][i]
print(ans)