import itertools
# 入力もらう
D,G = list(map(int,input().split()))
PC = []
for i in range(D):
    PC.append(list(map(int,input().split())))

#[0,0,0,0,0,0,0,0,0,0]という形で、どのボーナスをもらうかを管理したい
#例えば[1,0,0,0,1,0,0,0,0,0]は100点問題と500点問題のボーナスをもらうということ
#2^D通り(D<=10)だから全探索できる
#itertools使って2^D通りのケースを用意
a = [0,1]
Ls = list(itertools.product(a, repeat=D))

#pは100以下、Dは10以下だから解く問題数は多くて1000
#最大値を初期値として設定して、小さい値が実現できたら更新していく
out = 1000

#戦略としては、「ボーナスをもらう問題」を先に決めて計算し、
#その後「中途半端に解く問題」を合計得点がGに足るまで計算する、というもの。

for L in Ls: #どの問題でボーナスをもらうか、2^D通りのシナリオを逐一チェック
    #Lには「ボーナスをもらう問題」をどれにするか決めた結果が格納されている
    num = 0 #このシナリオにおける解いた問題の数
    point = 0 #このシナリオにおける得点

    #このシナリオにおいて「ボーナスをもらう問題」をまずは計算
    for i in range(D):
        if L[i]==1: #ボーナスをもらう問題では
            num+=PC[i][0] #解いた問題の数にプラス
            point+=PC[i][1] #特典もプラス
            point+=(i+1)*100*PC[i][0] #ボーナスもプラス

    #ここから、「中途半端に解く問題」の計算を行う
    #1問あたりの得点が高い方を選んだ方が得。D*100点問題から埋めていく。
    #ただしその問題でボーナスをもらっていた場合はすでに計算に入れているので、スキップする必要がある
    #さらに、重要なこととして、「ボーナスをもらわない問題」は1種類で十分である
    #なぜなら、「ボーナスをもらわない問題」を2問作るくらいなら、その2問のうち1問あたりの得点が高い方に集中させた方がいいからである。

    #「中途半端に解く問題」をどれにするか決めて、そのインデックスをhampaに格納する
    hampa = D-1 #D*100点問題
    while (L[hampa]==1)and(hampa>=0): #もし「ボーナスをもらう問題」に入れていたら
        hampa+=-1 #次に得点が高い問題を候補とする
        #ただし、[1,1,1,1,1,1,1,1,1,1]の時はそもそも「中途半端に解く問題」は作らない
        #hampaが負になったら抜ける、という方法でそれを実装している

    if hampa==-1: #先述のように、hampaが負の時は「中途半端に解く問題」は作らない
        cnt = 0
    else:
        cnt = 0 #「中途半端に解く問題」を解いた数を格納
        #「中途半端に解く問題」を解き進める条件は「今まだ得点がGに達していないこと」及び「あと一問解いてもまだ中途半端であること」
        while (point<G)and(cnt<PC[hampa][0]):
            cnt+=1
            num+=1
            point+=(hampa+1)*100

    #以上でこのシナリオにおける計算はおしまい、
    #「中途半端に解く問題」が1種類ではGに届いていないケースもある。
    #その場合はこの時点でpointはG未満であり、outの候補としては不適切。除くことが必要。
    if (point>=G)and(num<out): #問題数の最小値を更新したら、outに格納
        out=num
print(out)