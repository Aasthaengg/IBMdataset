n,m=map(int,input().split())
x=[2,5,5,4,5,6,3,7,6]
a=[]
for i in map(int,input().split()):
    a.append([i,x[i-1]])
a.sort(reverse=True)
dp=[0]*(n+1)
for i in range(m):
    for j in range(n+1):
        if j==0 or dp[j]!=0:
            if j+a[i][1]<=n:
                dp[j+a[i][1]]=max(dp[j+a[i][1]],dp[j]*10+a[i][0])
print(dp[n])
'''
dp[i]をちょうどi本使った時に表せる最大の数と考えれば
(aが数字の値で降順ソートされていることにも注意して)、
a[i][0]をi番目に大きい数字、a[i][1]をその数を表すのに
必要なマッチ棒の本数として、
dp[j+a[i][1]]=max(dp[j+a[i][1]],dp[j]*10+a[i][0])
という更新を行ってdp[n]を求めれば良いです。
また、ある数字の組が決まればマッチの本数が一意に定まり
一番上の桁から順に大きい数字を入れるのが最適なので、
aを降順ソートして大きい数字から順に取ってDPを行うことで
これを実現することができます。
e.g. 9→3→3→2の順番に取れば、
((((0×10+9)×10+3)×10+3)×10+2)=9332((((0×10+9)×10+3)×10+3)×10+2)=9332
'''