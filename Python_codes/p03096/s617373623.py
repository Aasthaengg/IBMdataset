
N = int(input())
C = [int(input()) for i in range(N)]
MOD = 10**9 + 7

# 左からi番目までの石を見ていくときに何通りの列ができるか
dp = [0] * N
# 一通りはあるので１
dp[0] = 1

# ある色が最後にどこで出てきたか覚えておく
last = dict()




for i,c in enumerate(C):
    if i == 0:
        last[c] = i
    else:
        dp[i] = dp[i-1]
        """

        たとえば
        112212121222
        のi=8（一番右にある1）を見ているとき、i=8の石を選んで間をひっくり返すか返さないかの選択肢がうまれる。
        その時増える起こりうる列の数は、最後の1が出てきたところから左について、何通りの列を作るれかに依存する。
        11111112 1222
        11222212 1222
        11221212 1222
        みたいなパターンがあり、i=8の1を選んでひっくり返すか、そのままにしておくかの選択の余地が生まれる。
        
        なので、
        ・最後に同じ数字が出てきた場所を覚えておく。
        ・そこまでのdpを今のdpに加える（i番目の石を選んでひっくり返す場合、最後にiと同じ色が出てきたところの手前のとりうる列の数だけ新たに列を作ることができるため）
        を繰り返せば、最終的な数が求まる

        """
        # cが既に出てきていて、さらに今見ている石と隣り合っていない場合
        if c in last and last[c] < i-1:
            dp[i] += dp[last[c]]
            dp[i] %= MOD
        last[c] = i

print(dp[-1])