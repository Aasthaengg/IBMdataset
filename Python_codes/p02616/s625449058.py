#!/usr/bin/env python3
import sys
MOD = 1000000007  # type: int

def solve(N: int, K: int, A: "List[int]"):
    if N == K:
        m = 1
        for a in A:
            m = m*a%MOD
        print(m)
    elif len(list(filter(lambda x: x>=0,A))) == 0 and K%2 == 1: # Can't be made positive, use from lower absolute value
        A = list(reversed(sorted(A)))
        m = 1
        for i in range(K):
            m = m*A[i]%MOD
        print(m)
    else: # We can make some combination to make positive result in this condition
        m = 1
        B = list(reversed(sorted([(abs(a),a) for a in A]))) # Make a sorted array with absolute value
        lastNegative = 0
        lastPositive = 1
        hadPositive = False
        for i in range(K): # Fill K elements with keeping the result positive. 
            a = B[i][1]
            if a < 0: 
                if lastNegative == 0: # If got a negative value and there are no last negative value kept aside
                    lastNegative = a # Keep this value aside and won't multiply to the result.
                else: # If got a negative value and there are negative value aside last time the loop found negative value, just multiply these 2 values to mul and reset the kept value.
                    m = m*lastNegative*a%MOD 
                    lastNegative = 0
            else:
                if a > 0: # If we got positive value, the value need to be kept aside for once to be swapped another negative value.
                    if hadPositive: # If there is positive value kept aside before, multiply that value to the result
                        m = m*lastPositive%MOD
                    lastPositive = a # The newest value need to be kept aside
                    hadPositive = True
                else:
                    m=m*a%MOD # Only for zero
        if lastNegative == 0: # This assumes the result is already positive. No need to tweak. But need to multiply the last positive value
            print(m*lastPositive%MOD)
        else:
            # Find next negative/positive value after Kth elements
            nextNegative = 0
            nextPositive = 0
            for i in range(K,N):
                b = B[i][1]
                if b < 0:
                    nextNegative = b
                    break
            for i in range(K,N):
                a = B[i][1]
                if a >=0:
                    nextPositive = a
                    break
            if not hadPositive: # This array must contain some non-negative value. This means the result value could be positive. But if there were no positive values in the first K values sorted by the absolute value, use just next positive value instead of the last negative values.
                print(m*nextPositive%MOD)
            elif lastNegative*nextNegative > nextPositive*lastPositive:
                print(m*lastNegative*nextNegative%MOD)
            else:
                print(m*nextPositive*lastPositive%MOD)


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: "List[int]"
    solve(N, K, A)

if __name__ == '__main__':
    main()
