
S = input()
N = len(S)
MOD = 10**9 + 7

"""
桁DPについて、S以下の数字で～の場合は
dp[i][j][k] : i桁目まで見たときに、その数字がSのj桁までより厳密に小さいか（一致する場合は0）、そこまでの値の13で割った時の値がkとなる個数（？をうめる方法の数）
といつもはしていたが、今回はSの中の？を埋める問題なので、jの厳密に一致するかどうかがいらない
なので、dp[i][j]は、i桁目まで見たときに、そこまでを13で割った時に13余るように？を決める方法の数
"""
dp = [[0 for _ in range(13)] for _ in range(N+1)]

# 0文字目まで見たときに13で割って余りが0になるのは１通り
dp[0][0] = 1

for i in range(N):
    for j in range(13):
        if S[i] == "?":
            # ?には0~9のいずれかを入れる
            for num in range(10):
                dp[i+1][(10*j + num) % 13] += dp[i][j]
                dp[i+1][(10*j + num) % 13] %= MOD
        
        # i文字目が13でない場合は
        else:
            # i番目の数字を13で割った余り
            num = ord(S[i]) - ord("0")
            dp[i+1][(10*j + num) % 13] += dp[i][j]
            dp[i+1][(10*j + num) % 13] %= MOD


print(dp[-1][5])