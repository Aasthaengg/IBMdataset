"""

問題:
N 頂点 M 辺の重み付き有向グラフがあります。
i(1≦i≦M) 番目の辺は 頂点 ai から 頂点 bi を重み ciで結びます。
このグラフと駒を利用して、次の1人ゲームを行います。
最初、駒を頂点 1に置いて、プレイヤーのスコアを 0とします。
プレイヤーは、次の条件で駒を繰り返し移動させることができます。
- 頂点 aiに駒があるとき、i 番目の辺を利用して頂点 bi に移動する。移動後にプレイヤーのスコアが ci加算される。
頂点 Nに駒があるときのみ、ゲームを終了できます。
なお、与えられる有向グラフの上で頂点 1 から頂点 Nに移動できることは保障されています。
プレイヤーがゲーム終了時のスコアを出来るだけ大きくするような行動を取ったとき、ゲーム終了時のスコアはいくつになるでしょうか?
ゲーム終了時のスコアをいくらでも大きくできる場合は inf と出力してください。

制約:
- 2≦N≦1000
- 1≦M≦min(N(N−1),2000)
- 1≦ai,bi≦N(1≦i≦M)
- ai≠bi(1≦i≦M)
- ai≠ajまたは bi≠bj(1≦i<j≦M)
- −10 ** 9≦ci≦10 ** 9(1≦i≦M)
- ciは整数である。
- 与えられるグラフには、頂点 1から頂点 N への経路が存在する。

検討:
- 閉路が存在する場合、スコアをいくらでも大きくできる可能性がある
- 閉路を1周することで得られるスコア合計の符合によってinfにできるかどうかが判定可能
  - 符合が正: inf
  - 符合が0以下: 最短でNに到達したときのスコアが解
- 閉路が複数ある場合はどうするか
  - 1周したときに得られるスコア合計の符合が正かどうかで判断

必要な処理:
- 最短経路探索: ダイクストラ法? -> ベルマンフォード法（コストに正負があるため）
- 閉路を見つけ出す
- 閉路を1周したときのスコア合計

計算時間:
- ベルマンフォード法の時間計算量はO(NM)
- 解説通りにpythonで実装したらTLE判定...(約2100ms)
- 制約通りでいけば、NM = 1000 * 2000 = 2 * 10 ** 6
- 20msの化け物がいる...
"""

n, m = map(int, input().split())
edges = []
for _ in range(m):
    a, b, c = map(int, input().split())
    edges.append([a-1, b-1, -c])

inf = 10 ** 18
dist = [inf for _ in range(n)]
dist[0] = 0

for i in range(n-1):
    for a, b, c in edges:
        dist[b] = min(dist[b], dist[a] + c)

for i in range(n):
    for a, b, c in edges:
        if dist[a] + c < dist[b]:
            dist[b] = -inf

if -inf == dist[-1]:
    print("inf")
else:
    print(-dist[-1])
