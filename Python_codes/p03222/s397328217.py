

"""
AtCoder Beginner Contest 113  D - Number of Amidakuji

愚直に考えると、
・それぞれの縦棒の間に、横棒があるかないかの2通り。これがある高さhだけで、2^(W-1)通りある（横棒が２連続で続かないので、厳密には違うが）。
・これが高さH（最大100個分）あるので、(2^7)^100 とか？とにかく全探索は間に合わない。

メタ視点だが、W<=8なので、bitDPとかやれそう。
愚直解の何がよくないかというと、たとえば H = 6,W = 4 みたいなあみだくじについて考えるとして、
・この中で上から3段目までが同じでそれより下が異なるあみだくじというのがあるが、同じ部分も毎回シミュレートしてしまうのが重複計算になって無駄。

なので、高さごとに取りうる横棒のパターンを確認して、それらについて移動先の場合の数を求めていけばいいか。

各高さについて毎回横棒のパターンをbitで探索するが何故か思いつかなかった。
"""

H,W,K = map(int, input().split())
MOD = 10**9 + 7


dp = [[0 for _ in range(W)] for _ in range(H+1)]
dp[0][0] = 1

ws = set()
for bit in range(1 << (W-1)):
    if "11" in bin(bit):
        continue
    ws.add(bit)


for i in range(H):
    for bit in ws:
        # 高さi、左からj本目の縦棒にいるとき、どう移動するか。
        for j in range(W):
          

            # 右に移る棒がある時に、右に行ってから下へ移動する場合
            if j != W-1 and bit & (1 << (W-2-j)): # j=0 の時に左端に1が立っているか確認したい、
                    dp[i+1][j+1] += dp[i][j]
                    dp[i+1][j+1] %= MOD

            # 左に移る棒があるときに、左に行ってから下へ移動する場合
            elif j != 0 and bit & (1 << (W-1-j)): # j=W-1 のときに、右端に1が立っているか確認したい。
                dp[i+1][j-1] += dp[i][j]
                dp[i+1][j-1] %= MOD

            else:
                  # そのまま下への移動
                dp[i+1][j] += dp[i][j]
                dp[i+1][j] %= MOD
                #print(i,bin(bit),j,dp)



print(dp[-1][K-1])
#print(dp)
#print(ws)