
"""
まず貪欲的なアルゴリズムを組めるか考えてみる。
所持している宝石のうち、価値が負であるものはできるだけ、筒に入れたい。できれば価値の低い順に。
所持している宝石のうち、価値が0以上であるものは、筒に入れる意味がない。
筒にある宝石のうち、価値が正のものはできるだけ取り出したい。できれば価値の高い順に。

ここまで考えると、宝石を筒に入れる作業は最後にやればよいことがわかる。
むしろ最後に寄せないと、筒の中に残っている価値の高い宝石を取り出すときに、入れた宝石が邪魔になる。
また、最後に行うため、左から入れるか右から入れるかは関係ない。
あと入れる宝石は任意で選べるため、負の宝石のうち、価値の低いものを順番に入れれば良い。

ここまでくると、愚直にシミュレートすれば良いことがわかる。
取り出す作業をA回やる、と決める。O(min(N,K))
    左からL回、右からR(=A-L)回取り出すと決める。O(min(N,K))
        P = V[:L]+V[::-1][:R] とする。（Pは取り出した宝石の価値の配列）。
        P.sort()で価値が低い順に並べて、左から価値が負のものをK-A個まで捨てる。O(NlogN)

計算量としてはO(min(N,K)**2*NlogN)で十分高速
"""

N,K = map(int,input().split())
V = list(map(int,input().split()))

ans = 0
for A in range(min(N,K)+1):
    for L in range(A+1):
        R = A-L
        P = V[:L]+V[::-1][:R]
        P.sort()
        for i in range(min(K-A,A)):
            if P[i] < 0:
                P[i]=0
        ans = max(ans,sum(P))
print(ans)
