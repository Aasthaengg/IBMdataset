"""
N = 3456の場合を例に取る。
支払い額もしくはお釣りの一方の1円玉の枚数は0が最適。
支払い枚数をf(N)で書くことにする。

(pay, change) = (...6, ...0)が最適の場合
10円以上で支払額とお釣り金額の差は3450円より、
    f(3456) = f(345) + 6
(pay, change) = (...0, ...4)が最適の場合
10円以上で支払額とお釣り金額の差は3460円より、
    f(3456) = f(346) + 4

つまり一般に
    f(3456) = min(f(345) + 6, f(346) + 4)
今回は再帰は10^6回で重いのでdpを行う。具体的には
    [f(3), f(4)]
    [f(34), f(35)] = [min(f(3)+4, f(4)+7), min(f(3)+5, f(4)+5)]
    [f(345), f(346)] = [min(f(34)+5, f(35)+5), min(f(34)+6, f(35)+4)]
の２ペアずつ値を保持して小さい方から計算すれば良い。
"""

strN = input()

# dp最初
n = int(strN[0])
dp = [min(n, 11 - n), min(n + 1, 11 - (n + 1))] # n == 9の場合も成立

for s in strN[1:]:
    n = int(s)
    dp = [min(dp[0] + n, dp[1] + (10 - n)), min(dp[0] + (n + 1), dp[1] + (10 - (n + 1)))]
    # 偶然、n == 0 or 9の場合もカバーできてる

print(dp[0])
